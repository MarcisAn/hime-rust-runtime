/*
 * WARNING: this file has been generated by
 * Hime Parser Generator 4.0.0
 */

package fr.cenotelie.hime.tests.executor;

import fr.cenotelie.hime.redist.ASTNode;
import fr.cenotelie.hime.redist.ParseResult;
import fr.cenotelie.hime.redist.SemanticAction;
import fr.cenotelie.hime.redist.SemanticBody;
import fr.cenotelie.hime.redist.Symbol;
import fr.cenotelie.hime.redist.parsers.InitializationException;
import fr.cenotelie.hime.redist.parsers.LRkAutomaton;
import fr.cenotelie.hime.redist.parsers.LRkParser;

import java.util.Map;

/**
 * Represents a parser
 */
class ExpectedTreeParser extends LRkParser {
    /**
     * The automaton for this parser
     */
    private static final LRkAutomaton COMMON_AUTOMATON = LRkAutomaton.find(ExpectedTreeParser.class, "ExpectedTreeParser.bin");
    /**
     * Contains the constant IDs for the variables and virtuals in this parser
     */
    public static class ID {
        /**
         * The unique identifier for variable option
         */
        public static final int VARIABLE_OPTION = 0x001F;
        /**
         * The unique identifier for variable terminal_def_atom
         */
        public static final int VARIABLE_TERMINAL_DEF_ATOM = 0x0020;
        /**
         * The unique identifier for variable terminal_def_element
         */
        public static final int VARIABLE_TERMINAL_DEF_ELEMENT = 0x0021;
        /**
         * The unique identifier for variable terminal_def_cardinalilty
         */
        public static final int VARIABLE_TERMINAL_DEF_CARDINALILTY = 0x0022;
        /**
         * The unique identifier for variable terminal_def_repetition
         */
        public static final int VARIABLE_TERMINAL_DEF_REPETITION = 0x0023;
        /**
         * The unique identifier for variable terminal_def_fragment
         */
        public static final int VARIABLE_TERMINAL_DEF_FRAGMENT = 0x0024;
        /**
         * The unique identifier for variable terminal_def_restrict
         */
        public static final int VARIABLE_TERMINAL_DEF_RESTRICT = 0x0025;
        /**
         * The unique identifier for variable terminal_definition
         */
        public static final int VARIABLE_TERMINAL_DEFINITION = 0x0026;
        /**
         * The unique identifier for variable terminal_rule
         */
        public static final int VARIABLE_TERMINAL_RULE = 0x0027;
        /**
         * The unique identifier for variable terminal_fragment
         */
        public static final int VARIABLE_TERMINAL_FRAGMENT = 0x0028;
        /**
         * The unique identifier for variable terminal_context
         */
        public static final int VARIABLE_TERMINAL_CONTEXT = 0x0029;
        /**
         * The unique identifier for variable terminal_item
         */
        public static final int VARIABLE_TERMINAL_ITEM = 0x002A;
        /**
         * The unique identifier for variable rule_sym_action
         */
        public static final int VARIABLE_RULE_SYM_ACTION = 0x002B;
        /**
         * The unique identifier for variable rule_sym_virtual
         */
        public static final int VARIABLE_RULE_SYM_VIRTUAL = 0x002C;
        /**
         * The unique identifier for variable rule_sym_ref_params
         */
        public static final int VARIABLE_RULE_SYM_REF_PARAMS = 0x002D;
        /**
         * The unique identifier for variable rule_sym_ref_template
         */
        public static final int VARIABLE_RULE_SYM_REF_TEMPLATE = 0x002E;
        /**
         * The unique identifier for variable rule_sym_ref_simple
         */
        public static final int VARIABLE_RULE_SYM_REF_SIMPLE = 0x002F;
        /**
         * The unique identifier for variable rule_def_atom
         */
        public static final int VARIABLE_RULE_DEF_ATOM = 0x0030;
        /**
         * The unique identifier for variable rule_def_context
         */
        public static final int VARIABLE_RULE_DEF_CONTEXT = 0x0031;
        /**
         * The unique identifier for variable rule_def_sub
         */
        public static final int VARIABLE_RULE_DEF_SUB = 0x0032;
        /**
         * The unique identifier for variable rule_def_element
         */
        public static final int VARIABLE_RULE_DEF_ELEMENT = 0x0033;
        /**
         * The unique identifier for variable rule_def_tree_action
         */
        public static final int VARIABLE_RULE_DEF_TREE_ACTION = 0x0034;
        /**
         * The unique identifier for variable rule_def_repetition
         */
        public static final int VARIABLE_RULE_DEF_REPETITION = 0x0035;
        /**
         * The unique identifier for variable rule_def_fragment
         */
        public static final int VARIABLE_RULE_DEF_FRAGMENT = 0x0036;
        /**
         * The unique identifier for variable rule_def_choice
         */
        public static final int VARIABLE_RULE_DEF_CHOICE = 0x0037;
        /**
         * The unique identifier for variable rule_definition
         */
        public static final int VARIABLE_RULE_DEFINITION = 0x0038;
        /**
         * The unique identifier for variable rule_template_params
         */
        public static final int VARIABLE_RULE_TEMPLATE_PARAMS = 0x0039;
        /**
         * The unique identifier for variable cf_rule_template
         */
        public static final int VARIABLE_CF_RULE_TEMPLATE = 0x003A;
        /**
         * The unique identifier for variable cf_rule_simple
         */
        public static final int VARIABLE_CF_RULE_SIMPLE = 0x003B;
        /**
         * The unique identifier for variable cf_rule
         */
        public static final int VARIABLE_CF_RULE = 0x003C;
        /**
         * The unique identifier for variable grammar_options
         */
        public static final int VARIABLE_GRAMMAR_OPTIONS = 0x003D;
        /**
         * The unique identifier for variable grammar_terminals
         */
        public static final int VARIABLE_GRAMMAR_TERMINALS = 0x003E;
        /**
         * The unique identifier for variable grammar_cf_rules
         */
        public static final int VARIABLE_GRAMMAR_CF_RULES = 0x003F;
        /**
         * The unique identifier for variable grammar_parency
         */
        public static final int VARIABLE_GRAMMAR_PARENCY = 0x0040;
        /**
         * The unique identifier for variable cf_grammar
         */
        public static final int VARIABLE_CF_GRAMMAR = 0x0041;
        /**
         * The unique identifier for variable file
         */
        public static final int VARIABLE_FILE = 0x0042;
        /**
         * The unique identifier for variable fixture
         */
        public static final int VARIABLE_FIXTURE = 0x0063;
        /**
         * The unique identifier for variable header
         */
        public static final int VARIABLE_HEADER = 0x0064;
        /**
         * The unique identifier for variable test
         */
        public static final int VARIABLE_TEST = 0x0065;
        /**
         * The unique identifier for variable test_matches
         */
        public static final int VARIABLE_TEST_MATCHES = 0x0066;
        /**
         * The unique identifier for variable test_no_match
         */
        public static final int VARIABLE_TEST_NO_MATCH = 0x0067;
        /**
         * The unique identifier for variable test_fails
         */
        public static final int VARIABLE_TEST_FAILS = 0x0068;
        /**
         * The unique identifier for variable test_output
         */
        public static final int VARIABLE_TEST_OUTPUT = 0x0069;
        /**
         * The unique identifier for variable tree
         */
        public static final int VARIABLE_TREE = 0x006A;
        /**
         * The unique identifier for variable check
         */
        public static final int VARIABLE_CHECK = 0x006B;
        /**
         * The unique identifier for variable children
         */
        public static final int VARIABLE_CHILDREN = 0x006C;
        /**
         * The unique identifier for virtual range
         */
        public static final int VIRTUAL_RANGE = 0x0047;
        /**
         * The unique identifier for virtual concat
         */
        public static final int VIRTUAL_CONCAT = 0x004B;
        /**
         * The unique identifier for virtual emptypart
         */
        public static final int VIRTUAL_EMPTYPART = 0x0058;
    }
    /**
     * The collection of variables matched by this parser
     *
     * The variables are in an order consistent with the automaton,
     * so that variable indices in the automaton can be used to retrieve the variables in this table
     */
    private static final Symbol[] variables = {
        new Symbol(0x001F, "option"), 
        new Symbol(0x0020, "terminal_def_atom"), 
        new Symbol(0x0021, "terminal_def_element"), 
        new Symbol(0x0022, "terminal_def_cardinalilty"), 
        new Symbol(0x0023, "terminal_def_repetition"), 
        new Symbol(0x0024, "terminal_def_fragment"), 
        new Symbol(0x0025, "terminal_def_restrict"), 
        new Symbol(0x0026, "terminal_definition"), 
        new Symbol(0x0027, "terminal_rule"), 
        new Symbol(0x0028, "terminal_fragment"), 
        new Symbol(0x0029, "terminal_context"), 
        new Symbol(0x002A, "terminal_item"), 
        new Symbol(0x002B, "rule_sym_action"), 
        new Symbol(0x002C, "rule_sym_virtual"), 
        new Symbol(0x002D, "rule_sym_ref_params"), 
        new Symbol(0x002E, "rule_sym_ref_template"), 
        new Symbol(0x002F, "rule_sym_ref_simple"), 
        new Symbol(0x0030, "rule_def_atom"), 
        new Symbol(0x0031, "rule_def_context"), 
        new Symbol(0x0032, "rule_def_sub"), 
        new Symbol(0x0033, "rule_def_element"), 
        new Symbol(0x0034, "rule_def_tree_action"), 
        new Symbol(0x0035, "rule_def_repetition"), 
        new Symbol(0x0036, "rule_def_fragment"), 
        new Symbol(0x0037, "rule_def_choice"), 
        new Symbol(0x0038, "rule_definition"), 
        new Symbol(0x0039, "rule_template_params"), 
        new Symbol(0x003A, "cf_rule_template"), 
        new Symbol(0x003B, "cf_rule_simple"), 
        new Symbol(0x003C, "cf_rule"), 
        new Symbol(0x003D, "grammar_options"), 
        new Symbol(0x003E, "grammar_terminals"), 
        new Symbol(0x003F, "grammar_cf_rules"), 
        new Symbol(0x0040, "grammar_parency"), 
        new Symbol(0x0041, "cf_grammar"), 
        new Symbol(0x0042, "file"), 
        new Symbol(0x004C, "__V76"), 
        new Symbol(0x004D, "__V77"), 
        new Symbol(0x004E, "__V78"), 
        new Symbol(0x0051, "__V81"), 
        new Symbol(0x0054, "__V84"), 
        new Symbol(0x0057, "__V87"), 
        new Symbol(0x0059, "__V89"), 
        new Symbol(0x005A, "__V90"), 
        new Symbol(0x005B, "__V91"), 
        new Symbol(0x005C, "__V92"), 
        new Symbol(0x005D, "__V93"), 
        new Symbol(0x005F, "__V95"), 
        new Symbol(0x0061, "__V97"), 
        new Symbol(0x0063, "fixture"), 
        new Symbol(0x0064, "header"), 
        new Symbol(0x0065, "test"), 
        new Symbol(0x0066, "test_matches"), 
        new Symbol(0x0067, "test_no_match"), 
        new Symbol(0x0068, "test_fails"), 
        new Symbol(0x0069, "test_output"), 
        new Symbol(0x006A, "tree"), 
        new Symbol(0x006B, "check"), 
        new Symbol(0x006C, "children"), 
        new Symbol(0x006D, "__V109"), 
        new Symbol(0x0076, "__V118"), 
        new Symbol(0x0077, "__V119"), 
        new Symbol(0x0079, "__V121"), 
        new Symbol(0x007A, "__VAxiom") };
    /**
     * The collection of virtuals matched by this parser
     *
     * The virtuals are in an order consistent with the automaton,
     * so that virtual indices in the automaton can be used to retrieve the virtuals in this table
     */
    private static final Symbol[] virtuals = {
        new Symbol(0x0047, "range"), 
        new Symbol(0x004B, "concat"), 
        new Symbol(0x0058, "emptypart") };
    /**
     * Initializes a new instance of the parser
     *
     * @param lexer The input lexer
     */
    public ExpectedTreeParser(ExpectedTreeLexer lexer) {
        super(COMMON_AUTOMATON, variables, virtuals, null, lexer);
    }

    /*
     * Visitor interface
     */
    public static class Visitor {
        public void onTerminalSeparator(ASTNode node) {}
        public void onTerminalName(ASTNode node) {}
        public void onTerminalInteger(ASTNode node) {}
        public void onTerminalLiteralString(ASTNode node) {}
        public void onTerminalLiteralAny(ASTNode node) {}
        public void onTerminalLiteralText(ASTNode node) {}
        public void onTerminalLiteralClass(ASTNode node) {}
        public void onTerminalUnicodeBlock(ASTNode node) {}
        public void onTerminalUnicodeCategory(ASTNode node) {}
        public void onTerminalUnicodeCodepoint(ASTNode node) {}
        public void onTerminalUnicodeSpanMarker(ASTNode node) {}
        public void onTerminalOperatorOptional(ASTNode node) {}
        public void onTerminalOperatorZeromore(ASTNode node) {}
        public void onTerminalOperatorOnemore(ASTNode node) {}
        public void onTerminalOperatorUnion(ASTNode node) {}
        public void onTerminalOperatorDifference(ASTNode node) {}
        public void onTerminalTreeActionPromote(ASTNode node) {}
        public void onTerminalTreeActionDrop(ASTNode node) {}
        public void onTerminalBlockOptions(ASTNode node) {}
        public void onTerminalBlockTerminals(ASTNode node) {}
        public void onTerminalBlockRules(ASTNode node) {}
        public void onTerminalBlockContext(ASTNode node) {}
        public void onTerminalNodeName(ASTNode node) {}
        public void onVariableOption(ASTNode node) {}
        public void onVariableTerminalDefAtom(ASTNode node) {}
        public void onVariableTerminalDefElement(ASTNode node) {}
        public void onVariableTerminalDefCardinalilty(ASTNode node) {}
        public void onVariableTerminalDefRepetition(ASTNode node) {}
        public void onVariableTerminalDefFragment(ASTNode node) {}
        public void onVariableTerminalDefRestrict(ASTNode node) {}
        public void onVariableTerminalDefinition(ASTNode node) {}
        public void onVariableTerminalRule(ASTNode node) {}
        public void onVariableTerminalFragment(ASTNode node) {}
        public void onVariableTerminalContext(ASTNode node) {}
        public void onVariableTerminalItem(ASTNode node) {}
        public void onVariableRuleSymAction(ASTNode node) {}
        public void onVariableRuleSymVirtual(ASTNode node) {}
        public void onVariableRuleSymRefParams(ASTNode node) {}
        public void onVariableRuleSymRefTemplate(ASTNode node) {}
        public void onVariableRuleSymRefSimple(ASTNode node) {}
        public void onVariableRuleDefAtom(ASTNode node) {}
        public void onVariableRuleDefContext(ASTNode node) {}
        public void onVariableRuleDefSub(ASTNode node) {}
        public void onVariableRuleDefElement(ASTNode node) {}
        public void onVariableRuleDefTreeAction(ASTNode node) {}
        public void onVariableRuleDefRepetition(ASTNode node) {}
        public void onVariableRuleDefFragment(ASTNode node) {}
        public void onVariableRuleDefChoice(ASTNode node) {}
        public void onVariableRuleDefinition(ASTNode node) {}
        public void onVariableRuleTemplateParams(ASTNode node) {}
        public void onVariableCfRuleTemplate(ASTNode node) {}
        public void onVariableCfRuleSimple(ASTNode node) {}
        public void onVariableCfRule(ASTNode node) {}
        public void onVariableGrammarOptions(ASTNode node) {}
        public void onVariableGrammarTerminals(ASTNode node) {}
        public void onVariableGrammarCfRules(ASTNode node) {}
        public void onVariableGrammarParency(ASTNode node) {}
        public void onVariableCfGrammar(ASTNode node) {}
        public void onVariableFile(ASTNode node) {}
        public void onVariableFixture(ASTNode node) {}
        public void onVariableHeader(ASTNode node) {}
        public void onVariableTest(ASTNode node) {}
        public void onVariableTestMatches(ASTNode node) {}
        public void onVariableTestNoMatch(ASTNode node) {}
        public void onVariableTestFails(ASTNode node) {}
        public void onVariableTestOutput(ASTNode node) {}
        public void onVariableTree(ASTNode node) {}
        public void onVariableCheck(ASTNode node) {}
        public void onVariableChildren(ASTNode node) {}
        public void onVirtualRange(ASTNode node) {}
        public void onVirtualConcat(ASTNode node) {}
        public void onVirtualEmptypart(ASTNode node) {}
    }

    /*
     * Walk the AST of a result using a visitor
     *
     * @param result  The parse result
     * @param visitor The visitor to use
     */
    public static void visit(ParseResult result, Visitor visitor) {
        visitASTNode(result.getRoot(), visitor);
    }

    /*
     * Walk the sub-AST from the specified node using a visitor
     *
     * @param node    The AST node to start from
     * @param visitor The visitor to use
     */
    public static void visitASTNode(ASTNode node, Visitor visitor) {
        for (ASTNode child : node.getChildren())
            visitASTNode(child, visitor);
        switch(node.getSymbol().getID()) {
            case 0x0007: visitor.onTerminalSeparator(node); break;
            case 0x0009: visitor.onTerminalName(node); break;
            case 0x000A: visitor.onTerminalInteger(node); break;
            case 0x000C: visitor.onTerminalLiteralString(node); break;
            case 0x000D: visitor.onTerminalLiteralAny(node); break;
            case 0x000E: visitor.onTerminalLiteralText(node); break;
            case 0x000F: visitor.onTerminalLiteralClass(node); break;
            case 0x0010: visitor.onTerminalUnicodeBlock(node); break;
            case 0x0011: visitor.onTerminalUnicodeCategory(node); break;
            case 0x0012: visitor.onTerminalUnicodeCodepoint(node); break;
            case 0x0013: visitor.onTerminalUnicodeSpanMarker(node); break;
            case 0x0014: visitor.onTerminalOperatorOptional(node); break;
            case 0x0015: visitor.onTerminalOperatorZeromore(node); break;
            case 0x0016: visitor.onTerminalOperatorOnemore(node); break;
            case 0x0017: visitor.onTerminalOperatorUnion(node); break;
            case 0x0018: visitor.onTerminalOperatorDifference(node); break;
            case 0x0019: visitor.onTerminalTreeActionPromote(node); break;
            case 0x001A: visitor.onTerminalTreeActionDrop(node); break;
            case 0x001B: visitor.onTerminalBlockOptions(node); break;
            case 0x001C: visitor.onTerminalBlockTerminals(node); break;
            case 0x001D: visitor.onTerminalBlockRules(node); break;
            case 0x001E: visitor.onTerminalBlockContext(node); break;
            case 0x0062: visitor.onTerminalNodeName(node); break;
            case 0x001F: visitor.onVariableOption(node); break;
            case 0x0020: visitor.onVariableTerminalDefAtom(node); break;
            case 0x0021: visitor.onVariableTerminalDefElement(node); break;
            case 0x0022: visitor.onVariableTerminalDefCardinalilty(node); break;
            case 0x0023: visitor.onVariableTerminalDefRepetition(node); break;
            case 0x0024: visitor.onVariableTerminalDefFragment(node); break;
            case 0x0025: visitor.onVariableTerminalDefRestrict(node); break;
            case 0x0026: visitor.onVariableTerminalDefinition(node); break;
            case 0x0027: visitor.onVariableTerminalRule(node); break;
            case 0x0028: visitor.onVariableTerminalFragment(node); break;
            case 0x0029: visitor.onVariableTerminalContext(node); break;
            case 0x002A: visitor.onVariableTerminalItem(node); break;
            case 0x002B: visitor.onVariableRuleSymAction(node); break;
            case 0x002C: visitor.onVariableRuleSymVirtual(node); break;
            case 0x002D: visitor.onVariableRuleSymRefParams(node); break;
            case 0x002E: visitor.onVariableRuleSymRefTemplate(node); break;
            case 0x002F: visitor.onVariableRuleSymRefSimple(node); break;
            case 0x0030: visitor.onVariableRuleDefAtom(node); break;
            case 0x0031: visitor.onVariableRuleDefContext(node); break;
            case 0x0032: visitor.onVariableRuleDefSub(node); break;
            case 0x0033: visitor.onVariableRuleDefElement(node); break;
            case 0x0034: visitor.onVariableRuleDefTreeAction(node); break;
            case 0x0035: visitor.onVariableRuleDefRepetition(node); break;
            case 0x0036: visitor.onVariableRuleDefFragment(node); break;
            case 0x0037: visitor.onVariableRuleDefChoice(node); break;
            case 0x0038: visitor.onVariableRuleDefinition(node); break;
            case 0x0039: visitor.onVariableRuleTemplateParams(node); break;
            case 0x003A: visitor.onVariableCfRuleTemplate(node); break;
            case 0x003B: visitor.onVariableCfRuleSimple(node); break;
            case 0x003C: visitor.onVariableCfRule(node); break;
            case 0x003D: visitor.onVariableGrammarOptions(node); break;
            case 0x003E: visitor.onVariableGrammarTerminals(node); break;
            case 0x003F: visitor.onVariableGrammarCfRules(node); break;
            case 0x0040: visitor.onVariableGrammarParency(node); break;
            case 0x0041: visitor.onVariableCfGrammar(node); break;
            case 0x0042: visitor.onVariableFile(node); break;
            case 0x0063: visitor.onVariableFixture(node); break;
            case 0x0064: visitor.onVariableHeader(node); break;
            case 0x0065: visitor.onVariableTest(node); break;
            case 0x0066: visitor.onVariableTestMatches(node); break;
            case 0x0067: visitor.onVariableTestNoMatch(node); break;
            case 0x0068: visitor.onVariableTestFails(node); break;
            case 0x0069: visitor.onVariableTestOutput(node); break;
            case 0x006A: visitor.onVariableTree(node); break;
            case 0x006B: visitor.onVariableCheck(node); break;
            case 0x006C: visitor.onVariableChildren(node); break;
            case 0x0047: visitor.onVirtualRange(node); break;
            case 0x004B: visitor.onVirtualConcat(node); break;
            case 0x0058: visitor.onVirtualEmptypart(node); break;
        }
    }
}
